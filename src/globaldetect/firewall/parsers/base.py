"""
Base firewall parser class.

Copyright (c) 2025 DNS Science.io, an After Dark Systems, LLC company.
All rights reserved.
"""

from abc import ABC, abstractmethod
from pathlib import Path

from globaldetect.firewall.models import FirewallPolicy, FirewallVendor


class FirewallParser(ABC):
    """Base class for firewall rule parsers."""

    VENDOR: FirewallVendor

    @abstractmethod
    def parse(self, content: str) -> FirewallPolicy:
        """Parse firewall rules from string content.

        Args:
            content: Raw firewall rule export content

        Returns:
            Parsed FirewallPolicy object
        """
        pass

    def parse_file(self, path: str | Path) -> FirewallPolicy:
        """Parse firewall rules from a file.

        Args:
            path: Path to firewall rule export file

        Returns:
            Parsed FirewallPolicy object
        """
        path = Path(path)
        content = path.read_text()
        policy = self.parse(content)
        policy.name = path.name
        return policy

    @classmethod
    def detect_format(cls, content: str) -> FirewallVendor | None:
        """Attempt to detect firewall format from content.

        Args:
            content: Raw content to analyze

        Returns:
            Detected FirewallVendor or None
        """
        content_lower = content.lower()

        # iptables-save format
        if content.startswith("# Generated by iptables-save") or content.startswith("*filter"):
            return FirewallVendor.IPTABLES

        # nftables
        if "table inet" in content or "table ip " in content or "nft " in content_lower:
            return FirewallVendor.NFTABLES

        # ipfilter (ipf)
        if "pass in" in content_lower or "block in" in content_lower or "pass out" in content_lower:
            if "keep state" in content_lower or "keep frags" in content_lower:
                return FirewallVendor.IPFILTER

        # BSD pf
        if "scrub in" in content_lower or "antispoof" in content_lower:
            return FirewallVendor.PF

        # Checkpoint (typically JSON or XML)
        if '"type" : "access-rule"' in content or "<rule>" in content_lower:
            return FirewallVendor.CHECKPOINT

        # Cisco ASA
        if "access-list " in content_lower and ("permit " in content_lower or "deny " in content_lower):
            if "ciscoasa" in content_lower or "pix" in content_lower or "asa" in content_lower:
                return FirewallVendor.CISCO_ASA

        return None

    @classmethod
    def get_parser(cls, vendor: FirewallVendor) -> "FirewallParser":
        """Get parser instance for vendor.

        Args:
            vendor: Firewall vendor

        Returns:
            Parser instance

        Raises:
            ValueError: If vendor not supported
        """
        from globaldetect.firewall.parsers.iptables import IptablesParser
        from globaldetect.firewall.parsers.ipfilter import IpfilterParser
        from globaldetect.firewall.parsers.checkpoint import CheckpointParser

        parsers = {
            FirewallVendor.IPTABLES: IptablesParser,
            FirewallVendor.IPFILTER: IpfilterParser,
            FirewallVendor.CHECKPOINT: CheckpointParser,
        }

        parser_class = parsers.get(vendor)
        if not parser_class:
            raise ValueError(f"No parser available for vendor: {vendor}")

        return parser_class()

    @classmethod
    def auto_parse(cls, content: str) -> FirewallPolicy:
        """Auto-detect format and parse content.

        Args:
            content: Raw firewall rule content

        Returns:
            Parsed FirewallPolicy

        Raises:
            ValueError: If format cannot be detected
        """
        vendor = cls.detect_format(content)
        if not vendor:
            raise ValueError("Could not detect firewall format")

        parser = cls.get_parser(vendor)
        return parser.parse(content)
