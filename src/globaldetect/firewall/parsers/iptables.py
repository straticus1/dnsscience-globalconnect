"""
iptables-save output parser.

Parses the output of `iptables-save` command into structured
firewall policy objects.

Copyright (c) 2025 DNS Science.io, an After Dark Systems, LLC company.
All rights reserved.
"""

import re
import logging
from datetime import datetime

from globaldetect.firewall.parsers.base import FirewallParser
from globaldetect.firewall.models import (
    FirewallPolicy,
    FirewallTable,
    FirewallChain,
    FirewallRule,
    FirewallVendor,
    RuleAction,
    Protocol,
    AddressSpec,
    PortSpec,
)

logger = logging.getLogger(__name__)


class IptablesParser(FirewallParser):
    """Parser for iptables-save output format."""

    VENDOR = FirewallVendor.IPTABLES

    # Action mappings
    ACTION_MAP = {
        "ACCEPT": RuleAction.ACCEPT,
        "DROP": RuleAction.DROP,
        "REJECT": RuleAction.REJECT,
        "LOG": RuleAction.LOG,
        "RETURN": RuleAction.RETURN,
        "QUEUE": RuleAction.QUEUE,
        "MASQUERADE": RuleAction.MASQUERADE,
        "SNAT": RuleAction.SNAT,
        "DNAT": RuleAction.DNAT,
        "REDIRECT": RuleAction.REDIRECT,
        "MARK": RuleAction.MARK,
    }

    # Protocol mappings
    PROTOCOL_MAP = {
        "tcp": Protocol.TCP,
        "udp": Protocol.UDP,
        "icmp": Protocol.ICMP,
        "icmpv6": Protocol.ICMPV6,
        "gre": Protocol.GRE,
        "esp": Protocol.ESP,
        "ah": Protocol.AH,
        "sctp": Protocol.SCTP,
        "all": Protocol.ALL,
    }

    def parse(self, content: str) -> FirewallPolicy:
        """Parse iptables-save output.

        Args:
            content: iptables-save output content

        Returns:
            Parsed FirewallPolicy
        """
        policy = FirewallPolicy(
            vendor=FirewallVendor.IPTABLES,
            raw_content=content,
        )

        # Extract generation timestamp
        timestamp_match = re.search(
            r"# Generated by iptables-save.*on (.+)$",
            content,
            re.MULTILINE
        )
        if timestamp_match:
            policy.generated_at = timestamp_match.group(1).strip()

        # Extract version
        version_match = re.search(r"iptables-save v([\d.]+)", content)
        if version_match:
            policy.version = version_match.group(1)

        current_table: FirewallTable | None = None

        for line in content.splitlines():
            line = line.strip()

            # Skip empty lines and comments (except generation comment)
            if not line or line.startswith("#"):
                continue

            # Table definition
            if line.startswith("*"):
                table_name = line[1:]
                current_table = FirewallTable(name=table_name)
                policy.tables[table_name] = current_table
                continue

            # Chain definition with policy
            if line.startswith(":"):
                if current_table:
                    chain = self._parse_chain_definition(line)
                    if chain:
                        current_table.chains[chain.name] = chain
                continue

            # Rule definition
            if line.startswith("-A "):
                if current_table:
                    chain_name, rule = self._parse_rule(line)
                    if chain_name and rule:
                        if chain_name not in current_table.chains:
                            current_table.chains[chain_name] = FirewallChain(name=chain_name)
                        rule.rule_number = len(current_table.chains[chain_name].rules) + 1
                        current_table.chains[chain_name].rules.append(rule)
                continue

            # Commit - end of table
            if line == "COMMIT":
                current_table = None
                continue

        return policy

    def _parse_chain_definition(self, line: str) -> FirewallChain | None:
        """Parse chain definition line.

        Format: :CHAIN_NAME POLICY [packets:bytes]
        Example: :INPUT ACCEPT [1234:56789]
        """
        match = re.match(r":(\S+)\s+(\S+)(?:\s+\[(\d+):(\d+)\])?", line)
        if not match:
            return None

        name = match.group(1)
        policy_str = match.group(2)
        packets = int(match.group(3)) if match.group(3) else 0
        bytes_count = int(match.group(4)) if match.group(4) else 0

        # Map policy
        policy = self.ACTION_MAP.get(policy_str)
        if policy_str == "-":
            policy = None  # User-defined chain, no default policy

        return FirewallChain(
            name=name,
            policy=policy,
            packets=packets,
            bytes=bytes_count,
        )

    def _parse_rule(self, line: str) -> tuple[str | None, FirewallRule | None]:
        """Parse rule line.

        Format: -A CHAIN [options] -j TARGET [target-options]
        """
        # Extract chain name
        chain_match = re.match(r"-A\s+(\S+)\s+(.+)", line)
        if not chain_match:
            return None, None

        chain_name = chain_match.group(1)
        rule_part = chain_match.group(2)

        rule = FirewallRule(raw_rule=line)

        # Parse rule options using regex patterns
        self._parse_protocol(rule, rule_part)
        self._parse_source(rule, rule_part)
        self._parse_destination(rule, rule_part)
        self._parse_interfaces(rule, rule_part)
        self._parse_ports(rule, rule_part)
        self._parse_state(rule, rule_part)
        self._parse_icmp(rule, rule_part)
        self._parse_tcp_flags(rule, rule_part)
        self._parse_mac(rule, rule_part)
        self._parse_comment(rule, rule_part)
        self._parse_counters(rule, rule_part)
        self._parse_target(rule, rule_part)

        return chain_name, rule

    def _parse_protocol(self, rule: FirewallRule, text: str) -> None:
        """Parse protocol option."""
        match = re.search(r"(?:^|\s)-p\s+(\S+)", text)
        if match:
            proto = match.group(1).lower()
            # Handle negation
            if proto.startswith("!"):
                proto = proto[1:]
            rule.protocol = self.PROTOCOL_MAP.get(proto, Protocol.ANY)

    def _parse_source(self, rule: FirewallRule, text: str) -> None:
        """Parse source address option."""
        match = re.search(r"(?:^|\s)(-s|--source)\s+(!?\S+)", text)
        if match:
            addr = match.group(2)
            negated = addr.startswith("!")
            if negated:
                addr = addr[1:]
            rule.source = AddressSpec(address=addr, negated=negated)

    def _parse_destination(self, rule: FirewallRule, text: str) -> None:
        """Parse destination address option."""
        match = re.search(r"(?:^|\s)(-d|--destination)\s+(!?\S+)", text)
        if match:
            addr = match.group(2)
            negated = addr.startswith("!")
            if negated:
                addr = addr[1:]
            rule.destination = AddressSpec(address=addr, negated=negated)

    def _parse_interfaces(self, rule: FirewallRule, text: str) -> None:
        """Parse interface options."""
        in_match = re.search(r"(?:^|\s)-i\s+(\S+)", text)
        if in_match:
            rule.in_interface = in_match.group(1)

        out_match = re.search(r"(?:^|\s)-o\s+(\S+)", text)
        if out_match:
            rule.out_interface = out_match.group(1)

    def _parse_ports(self, rule: FirewallRule, text: str) -> None:
        """Parse port options."""
        # Source port
        sport_match = re.search(r"--sport\s+(\S+)", text)
        if sport_match:
            rule.source_port = self._parse_port_spec(sport_match.group(1))

        # Destination port
        dport_match = re.search(r"--dport\s+(\S+)", text)
        if dport_match:
            rule.destination_port = self._parse_port_spec(dport_match.group(1))

        # Multiport
        sports_match = re.search(r"--sports\s+(\S+)", text)
        if sports_match:
            rule.source_port = self._parse_port_spec(sports_match.group(1))

        dports_match = re.search(r"--dports\s+(\S+)", text)
        if dports_match:
            rule.destination_port = self._parse_port_spec(dports_match.group(1))

    def _parse_port_spec(self, port_str: str) -> PortSpec:
        """Parse port specification string."""
        spec = PortSpec()

        # Handle negation
        if port_str.startswith("!"):
            port_str = port_str[1:]

        # Range
        if ":" in port_str:
            parts = port_str.split(":")
            try:
                spec.port_range = (int(parts[0]), int(parts[1]))
            except ValueError:
                pass
        # Multiport
        elif "," in port_str:
            try:
                spec.multiport = [int(p) for p in port_str.split(",")]
            except ValueError:
                pass
        # Single port
        else:
            try:
                spec.port = int(port_str)
            except ValueError:
                pass

        return spec

    def _parse_state(self, rule: FirewallRule, text: str) -> None:
        """Parse connection state options."""
        # --state (older)
        state_match = re.search(r"--state\s+(\S+)", text)
        if state_match:
            rule.state = state_match.group(1).split(",")

        # --ctstate (conntrack)
        ctstate_match = re.search(r"--ctstate\s+(\S+)", text)
        if ctstate_match:
            rule.ctstate = ctstate_match.group(1).split(",")

    def _parse_icmp(self, rule: FirewallRule, text: str) -> None:
        """Parse ICMP type option."""
        match = re.search(r"--icmp-type\s+(\S+)", text)
        if match:
            rule.icmp_type = match.group(1)

    def _parse_tcp_flags(self, rule: FirewallRule, text: str) -> None:
        """Parse TCP flags option."""
        match = re.search(r"--tcp-flags\s+(\S+)\s+(\S+)", text)
        if match:
            mask = match.group(1).split(",")
            flags = match.group(2).split(",")
            rule.tcp_flags = {"mask": mask, "flags": flags}

    def _parse_mac(self, rule: FirewallRule, text: str) -> None:
        """Parse MAC source option."""
        match = re.search(r"--mac-source\s+(\S+)", text)
        if match:
            rule.mac_source = match.group(1)

    def _parse_comment(self, rule: FirewallRule, text: str) -> None:
        """Parse comment option."""
        match = re.search(r'--comment\s+"([^"]+)"', text)
        if match:
            rule.comment = match.group(1)

    def _parse_counters(self, rule: FirewallRule, text: str) -> None:
        """Parse packet/byte counters."""
        match = re.search(r"-c\s+(\d+)\s+(\d+)", text)
        if match:
            rule.packets = int(match.group(1))
            rule.bytes = int(match.group(2))

    def _parse_target(self, rule: FirewallRule, text: str) -> None:
        """Parse target/action and target options."""
        match = re.search(r"-j\s+(\S+)(?:\s+(.*))?$", text)
        if not match:
            return

        target = match.group(1)
        target_opts = match.group(2) or ""

        # Standard targets
        if target in self.ACTION_MAP:
            rule.action = self.ACTION_MAP[target]
        else:
            # User-defined chain
            rule.action = RuleAction.JUMP
            rule.target_chain = target

        # Parse target-specific options
        if target == "REJECT":
            reject_match = re.search(r"--reject-with\s+(\S+)", target_opts)
            if reject_match:
                rule.reject_with = reject_match.group(1)

        elif target == "LOG":
            prefix_match = re.search(r'--log-prefix\s+"([^"]+)"', target_opts)
            if prefix_match:
                rule.log_prefix = prefix_match.group(1)

            level_match = re.search(r"--log-level\s+(\S+)", target_opts)
            if level_match:
                rule.log_level = level_match.group(1)

        elif target == "SNAT":
            to_match = re.search(r"--to-source\s+(\S+)", target_opts)
            if to_match:
                rule.nat_to = to_match.group(1)

        elif target == "DNAT":
            to_match = re.search(r"--to-destination\s+(\S+)", target_opts)
            if to_match:
                nat_spec = to_match.group(1)
                if ":" in nat_spec:
                    parts = nat_spec.rsplit(":", 1)
                    rule.nat_to = parts[0]
                    try:
                        rule.nat_port = int(parts[1])
                    except ValueError:
                        pass
                else:
                    rule.nat_to = nat_spec

        elif target == "REDIRECT":
            to_match = re.search(r"--to-ports?\s+(\d+)", target_opts)
            if to_match:
                rule.nat_port = int(to_match.group(1))

        elif target == "MARK":
            mark_match = re.search(r"--set-mark\s+(\S+)", target_opts)
            if mark_match:
                try:
                    rule.mark_value = int(mark_match.group(1), 0)  # Handle hex
                except ValueError:
                    pass


class Ip6tablesParser(IptablesParser):
    """Parser for ip6tables-save output format."""

    def parse(self, content: str) -> FirewallPolicy:
        """Parse ip6tables-save output."""
        policy = super().parse(content)
        policy.ipv6_enabled = True
        return policy
